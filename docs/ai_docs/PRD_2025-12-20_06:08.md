# Product Requirement Document — OneClickSystemMonitor Agents

## 1. Overview
- **Purpose:** Provide a single-shot, code-driven system monitoring workflow that gathers CPU, memory, and disk metrics locally and then renders a plain-text status report.
- **Problems solved:** Automates psutil-based sampling, stores each metric for downstream summarization, and enforces readable health guidance (status labels + recommendations) in the summary output.
- **Explicit non-goals:** No continuous monitoring loop, no remote orchestration, no data persistence beyond the current run, and no interaction with external services beyond the local `psutil` library.

## 2. System Boundaries
- **Inside scope:** `agents/oneclicksystemmonitor/agent.py` (root sequential orchestration), the nested `ParallelAgent` gatherer, four `LlmAgent` sub-agents, and the tool implementations under `agents/oneclicksystemmonitor/tools/` that sample metrics, convert units, and format the summary report. All behavior must be derived from these Python modules.
- **Outside scope:** Any code outside `agents/oneclicksystemmonitor`, including web UI, docs in `/docs` (aside from referencing for style), scheduling, alerting, or external APIs beyond the standard library and `psutil` dependency.

## 3. Terminology & Definitions
1. **`oneclick_system_monitor`** — The root `SequentialAgent` that runs the info-gathering `ParallelAgent` and then the summary reporter in strict order.
2. **`system_info_gatherer`** — A `ParallelAgent` that fires the three metric-collection `LlmAgent`s at once so CPU, memory, and disk stats are sampled in parallel.
3. **Metric agents** — Each `LlmAgent` (`cpu_monitor`, `memory_monitor`, `disk_monitor`) is responsible for invoking a `FunctionTool` that calls the corresponding `collect_*_stats` helper and returns its response unaltered.
4. **`summary_reporter`** — An `LlmAgent` whose sole instruction is to execute `generate_summary_report` and emit the returned report text.
5. **Tool context state keys** — The `tool_context.state` dictionary stores `cpu_stats`, `memory_stats`, `disk_stats`, and `summary_report`, enabling downstream consumers to know where to find each payload.
6. **Status labels** — Named thresholds (`High usage`, `Moderate usage`, `Low usage`) that map to numeric cutoffs defined in `summary_tools.py` for CPU, memory, and disk sections.

## 4. Agent Inventory
#### `oneclick_system_monitor` (SequentialAgent)
- **Responsibilities:** Enforce a barrier so stat collection finishes before summary generation begins.
- **Inputs:** None beyond the implicit run context; it orchestrates child agents.
- **Outputs:** Final textual summary produced by `summary_reporter` and stored in `tool_context.state["summary_report"]`.
- **Lifecycle:** Start → run `system_info_gatherer` → wait for completion → run `summary_reporter` → end.
- **Tools / Callbacks:** None.

#### `system_info_gatherer` (ParallelAgent)
- **Responsibilities:** Execute CPU, memory, and disk agents concurrently, ensuring each `FunctionTool` runs without blocking the others.
- **Sub-agents:** `[cpu_monitor, memory_monitor, disk_monitor]` in code-defined order.
- **Inputs:** The shared `tool_context` (passed through ADK).
- **Outputs:** Each sub-agent writes to its state key (`cpu_stats`, `memory_stats`, `disk_stats`).
- **Lifecycle:** Start → spawn all sub-agents in parallel → wait for all to finish → propagate success/failure to the root sequential agent.
- **Tools / Callbacks:** None.

#### `cpu_monitor` (LlmAgent)
- **Responsibilities:** Call `collect_cpu_stats` through `FunctionTool(func=collect_cpu_stats)` and return the tool response verbatim.
- **Instruction:** Instructs the LLM to collect CPU usage and respond with the tool output.
- **Inputs:** `FunctionTool` that ties the agent to `collect_cpu_stats`.
- **Outputs:** Tool response saved under `tool_context.state["cpu_stats"]` and returned to the ParallelAgent.
- **Session State:** **writes:** `["cpu_stats"]`; **reads:** none explicitly.

#### `memory_monitor` (LlmAgent)
- **Responsibilities:** Invoke `collect_memory_stats` via its `FunctionTool` and emit the returned payload.
- **Outputs:** State key `memory_stats` contains the `status/data/error` dict; returned data includes totals, availability, swap, and cache metadata.
- **Session State:** **writes:** `["memory_stats"]`.

#### `disk_monitor` (LlmAgent)
- **Responsibilities:** Trigger `collect_disk_stats`, which is an `async` tool that gathers partitions, throughput, and fragmentation placeholders, and return its response.
- **Outputs:** `tool_context.state["disk_stats"]` stores the drives list, read/write throughput (might be `None`), and fragmentation metadata; this dict is returned unchanged.
- **Session State:** **writes:** `["disk_stats"]`.

#### `summary_reporter` (LlmAgent)
- **Responsibilities:** Execute `generate_summary_report` and respond with the plain-text report string (no additional explanation).
- **Inputs:** Reads shared state keys `["cpu_stats", "memory_stats", "disk_stats"]` via `ToolContext` inside `generate_summary_report`.
- **Outputs:** `tool_context.state["summary_report"]` receives the final string; the response payload contains `status`, `data.report`, and `error` fields.
- **Session State:** **reads:** `["cpu_stats", "memory_stats", "disk_stats"]`; **writes:** `["summary_report"]`.

## 5. Functional Requirements
1. The `oneclick_system_monitor` `SequentialAgent` must run `system_info_gatherer` first and only execute `summary_reporter` after `system_info_gatherer` completes, guaranteeing that metric state keys exist before summarization.
2. `system_info_gatherer` must be a `ParallelAgent` that invokes `cpu_monitor`, `memory_monitor`, and `disk_monitor` simultaneously so sampling latency depends on the slowest tool rather than the sum of all tools.
3. Each metric `LlmAgent` must include a `FunctionTool` configured with its respective helper (`collect_cpu_stats`, `collect_memory_stats`, or `collect_disk_stats`) and return that tool’s structured response exactly as the tool produces it.
4. `collect_cpu_stats` must sample per-core usage with `psutil.cpu_percent(interval=0.1, percpu=True)`, compute the rounded average as `usage_percent`, attempt to identify the top CPU process while handling `NoSuchProcess`, `AccessDenied`, and `ZombieProcess`, and record temperature readings when sensors are available; all results are written to `tool_context.state["cpu_stats"]` with fallback reason strings (`top_process_reason`, `temperature_reason`).
5. `collect_memory_stats` must read `psutil.virtual_memory()` and `psutil.swap_memory()`, convert byte counts to gigabytes via `bytes_to_gb`, include swap usage percentages, and only populate `cache_gb` when the `cached` attribute exists, otherwise setting `cache_reason`; this entire payload is saved as `memory_stats`.
6. `collect_disk_stats` must enumerate partitions from `psutil.disk_partitions(all=False)`, skip `tmpfs`/`devtmpfs`/empty filesystems, compute per-partition totals/free space, asynchronously sample throughput with two `psutil.disk_io_counters()` snapshots `THROUGHPUT_SAMPLE_INTERVAL` apart, and always include a `fragmentation_reason` message because fragmentation data is not computed; the resulting dict is stored in `disk_stats`.
7. Every tool must return a dictionary following `{"status": "ok", "data": {...}, "error": None}` so downstream agents can expect consistent contracts.
8. `generate_summary_report` must read the three stats keys from `tool_context.state`, produce section text for memory/CPU/disk using dedicated format helpers, accumulate notes for missing data or reasons supplied by the stats (e.g., unavailable sensors), derive section status labels via threshold constants (Memory: 20/40 %, CPU: 80/50 %, Disk: 85/70 %), compute `Overall` load (`High load` if any section high, `Moderate load` if none high but any moderate, otherwise `Low load`), append a `Notes` list when there are reasons or missing sections, and store the final string under `summary_report`.
9. If any metric is unavailable, `generate_summary_report` must still run, append a note such as “CPU stats unavailable.”, and include the `overall` status label derived solely from the available sections.
10. The summary result is always plain text containing emoji-prefixed section titles, specific numeric values (percentages/GB), top process/temperature/throughput data when available, a status line per section, and a final `Overall` line plus optional Notes.

## 6. Control Flow & Interactions
- Execution order is strictly sequential at the root: `system_info_gatherer` → `summary_reporter`. The `SequentialAgent` ensures `summary_reporter` waits until all parallel metric agents finish.
- Within `system_info_gatherer`, child agents execute in parallel; each wraps a `FunctionTool` that triggers its psutil-based helper. Their completion is independent from one another and from the summary agent until the parallel stage ends.
- Shared state (`tool_context.state`) acts as the coupling point: each `collect_*` helper writes `cpu_stats`, `memory_stats`, or `disk_stats`, and the summary tool reads those keys to compute narrative sections. This explicit contract prevents the summary from running without upstream data.
- Error propagation is handled through note lists: metrics record reason strings (e.g., `temperature_reason`, `throughput_reason`), and the summary report appends them under `Notes`, while the agent still returns an overall status message rather than failing the run.
- The summary agent does not modify underlying metrics; it only reads them, formats text, and writes `summary_report`, so it cannot mask stale data or mutate the metric payloads.

## 7. Configuration & Extensibility
- **Configurable parameters:** Sample interval constants (`CPU_SAMPLE_INTERVAL`, `THROUGHPUT_SAMPLE_INTERVAL`), threshold constants (`MEMORY_HIGH_THRESHOLD`, etc.), and unit conversion precision reside in `agents/oneclicksystemmonitor/tools/*` modules; adjusting them requires editing those definitions.
- **Hard-coded behavior:** Agent wiring (Sequential → Parallel → LlmAgents), the model `gemma-3-27b-it` for every `LlmAgent`, and the dependency on `FunctionTool` wrappers are explicit in `agent.py` and must remain unchanged unless a refactor is intentionally introduced.
- **Extensibility hooks:** Adding new metrics means creating a new `collect_*` helper, a corresponding `FunctionTool`, storing its state key, and including it in `system_info_gatherer` or the summary logic. The current summary code centralizes formatting logic, so new sections must update `_format_*` helpers and status aggregation.
- **RUN_CONFIG visibility:** `RUN_CONFIG` defines `streaming_mode=StreamingMode.NONE`, `max_llm_calls=6`, and custom metadata but is not currently attached to any agent; if applied, it would govern budget/policy for sequential execution.

## 8. Edge Cases & Failure Modes
- If no CPU process can be read (due to permission errors or the iteration exiting early), `top_process` remains `None`, and `collect_cpu_stats` sets `top_process_reason = "Top process data unavailable."` so the summary knows to emit that note.
- `psutil.sensors_temperatures` may raise `AttributeError`, `OSError`, or return empty dicts; in these cases the tool stores `temperature_reason = "CPU temperature not supported."` and the summary adds the same explanation to `Notes`.
- Partition enumeration or usage calls can raise `PermissionError`/`OSError`; such partitions are silently skipped, ensuring drives list only contains accessible mounts.
- `psutil.disk_io_counters()` might return `None` or throw `AttributeError`/`OSError`; the async helper responds with `throughput_reason = "Disk throughput not supported."` and the summary reports the reason instead of numeric throughput.
- Memory cache availability is platform-dependent; when `memory.cached` is absent, `cache_gb` stays `None` and `cache_reason = "Cache metric not available on this platform."` so the summary documents the limitation.
- If any of the three stats are entirely missing, the summary still renders, adds a `Notes` entry (e.g., “Disk stats unavailable.”), and interacts with the overall status based on the sections that do exist.

## 9. Explicit Invariants
1. Every agent in `agents/oneclicksystemmonitor` uses the `gemma-3-27b-it` model.
2. `system_info_gatherer` always completes before `summary_reporter` starts, preserving the sequential barrier.
3. The metric helpers always write their results to the designated keys (`cpu_stats`, `memory_stats`, `disk_stats`) in `tool_context.state` and return a `{status,data,error}` contract with `error` staying `None`.
4. `generate_summary_report` only reads from those state keys and writes `summary_report`; it never mutates `cpu_stats`/`memory_stats`/`disk_stats` or calls other tools.
5. `summary_report` always contains hierarchy: timestamp header → section texts → an `Overall` line → optional `Notes` list that enumerates missing data or reasons provided by the metric helpers.

## 10. Out-of-Scope
- No support for monitoring network throughput, GPU usage, or other hardware beyond CPU/memory/disk.
- Not designed for resiliency across multiple runs (no persistence, retries, or job scheduling).
- The agents do not include user-facing input handling or CLI parameters; the workflow only runs exactly once per invocation.
- No alerts, notifications, or export formats beyond the plain-text summary string.

## 11. Acceptance Criteria
1. When `oneclick_system_monitor` runs, `system_info_gatherer` completes first, each metric helper stores its state key, and `summary_reporter` only runs afterward, producing `tool_context.state["summary_report"]`.
2. Each `collect_*` function returns a dict with `status: "ok"`, numeric values converted to GB/MB (as defined), and `error: None`, even when optional readings (temperature, top process, throughput, cache) are unavailable.
3. The summary report contains emoji-prefixed section headings, numeric breakdowns, status lines that mirror the threshold logic, an `Overall` load indicator (`High load`, `Moderate load`, or `Low load`), and a `Notes` block listing every `*_reason` or missing section.
4. Missing stats do not crash the system; the summary still emits a `System Performance Summary (as of …)` header with only the available sections and records which sections were unavailable.
5. Aggregated state keys (`cpu_stats`, `memory_stats`, `disk_stats`, `summary_report`) exist by the end of the run so any future agent/tool can inspect them deterministically.

## Confidence-Weighted Check
- **Confidence:** 85% that this PRD enables a faithful, bit-for-bit reimplementation of `agents/oneclicksystemmonitor`.
- **Key assumptions:** Assumed the omission of `RUN_CONFIG` attachment to `root_agent` is deliberate and that the code should keep the same sequential/parallel wiring; assumed `FunctionTool` response contract always has `error = None` since the helpers never return other values.
- **Additional context to reach 95%+:** Confirmation that no other files define additional shared state keys (e.g., other agents writing to `tool_context.state`), clarification on whether `RUN_CONFIG` should be wired to the root agent, and runtime example outputs from each tool to validate formatting expectations.
